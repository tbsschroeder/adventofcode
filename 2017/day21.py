from numpy import rot90, flipud, fliplr

input = """../.. => ###/#../.#.
#./.. => ##./.#./...
##/.. => ..#/.#./#.#
.#/#. => ..#/.#./..#
##/#. => .../.##/##.
##/## => ###/#../#..
.../.../... => .#../.#../#..#/##..
#../.../... => ####/####/.###/####
.#./.../... => ####/..../#.#./.#.#
##./.../... => ..##/###./...#/##.#
#.#/.../... => .#../#..#/.#../#.#.
###/.../... => #.##/..##/##.#/..##
.#./#../... => .##./#..#/..../....
##./#../... => ##../.#../...#/####
..#/#../... => ##../###./...#/.#.#
#.#/#../... => ####/#.../..../##..
.##/#../... => #..#/..##/#..#/....
###/#../... => #.##/####/..#./#.#.
.../.#./... => #.##/.#.#/#.../...#
#../.#./... => .###/##.#/..../###.
.#./.#./... => ..#./.#../..../##..
##./.#./... => ##../...#/..../....
#.#/.#./... => ####/.#../..#./.###
###/.#./... => ..#./.###/##../.##.
.#./##./... => ###./#.#./.###/.##.
##./##./... => ...#/.#../.#../####
..#/##./... => ..#./#.../##../###.
#.#/##./... => #.../..../.#.#/.###
.##/##./... => #.#./.#../####/.###
###/##./... => .#.#/#.#./##../#...
.../#.#/... => #.##/##.#/..../#.#.
#../#.#/... => ##../#.##/###./###.
.#./#.#/... => ##../.#../#.##/###.
##./#.#/... => ##../##../..#./..#.
#.#/#.#/... => #.../.##./.###/###.
###/#.#/... => ##.#/##../.##./#...
.../###/... => ...#/####/..../#..#
#../###/... => ##.#/##.#/.##./#.#.
.#./###/... => .#../#.../.#.#/##.#
##./###/... => ##.#/#.#./#.../.#..
#.#/###/... => ..../#.../####/.#..
###/###/... => .#../#..#/.#../.#..
..#/.../#.. => .#.#/#.../..##/...#
#.#/.../#.. => ####/####/###./...#
.##/.../#.. => ####/.###/##.#/##..
###/.../#.. => ..##/..../...#/#.#.
.##/#../#.. => ###./..#./##.#/##.#
###/#../#.. => ##.#/...#/.##./.###
..#/.#./#.. => #.#./#.#./...#/#.#.
#.#/.#./#.. => ###./.#.#/#.#./.#..
.##/.#./#.. => #.#./.##./.###/#.#.
###/.#./#.. => #.../#.../#.#./.###
.##/##./#.. => .#.#/.##./..#./##..
###/##./#.. => .###/.##./#.##/..##
#../..#/#.. => #.#./#..#/###./.##.
.#./..#/#.. => ###./.###/...#/..##
##./..#/#.. => ###./##../####/.#.#
#.#/..#/#.. => ..#./.#../.##./.#..
.##/..#/#.. => ##.#/###./.##./#...
###/..#/#.. => ...#/..##/##.#/##.#
#../#.#/#.. => #.../.##./.#.#/.###
.#./#.#/#.. => #.##/...#/####/###.
##./#.#/#.. => .#../#.../.###/....
..#/#.#/#.. => ####/###./.#.#/#...
#.#/#.#/#.. => ###./..##/...#/#.##
.##/#.#/#.. => ##.#/..#./..##/.#.#
###/#.#/#.. => #.#./..../##../.###
#../.##/#.. => #..#/###./.#.#/##.#
.#./.##/#.. => #.../.###/.##./.###
##./.##/#.. => .#../###./.#../##.#
#.#/.##/#.. => .#../#.#./.#../#.##
.##/.##/#.. => ##../###./.#.#/.###
###/.##/#.. => ..##/...#/#.../.#..
#../###/#.. => #.##/#..#/####/###.
.#./###/#.. => .###/.#.#/#.#./..#.
##./###/#.. => ####/#.#./..##/#.##
..#/###/#.. => .###/##.#/.##./#.#.
#.#/###/#.. => #.##/###./.###/....
.##/###/#.. => #.##/..../.#../####
###/###/#.. => ##.#/###./.#../...#
.#./#.#/.#. => ..#./##.#/.#../###.
##./#.#/.#. => ..##/###./..#./.#.#
#.#/#.#/.#. => .#../..##/.#.#/.#.#
###/#.#/.#. => ##../#..#/.#../..#.
.#./###/.#. => #.../#..#/.#.#/....
##./###/.#. => ..../..##/..#./####
#.#/###/.#. => ..##/##.#/.###/...#
###/###/.#. => ##.#/#.##/..#./#.#.
#.#/..#/##. => #.../####/#.##/.###
###/..#/##. => ###./...#/.#.#/#..#
.##/#.#/##. => ..../.#.#/##.#/..##
###/#.#/##. => ###./.#../.#.#/###.
#.#/.##/##. => ###./.#../.#../.#.#
###/.##/##. => .##./..../..../#.##
.##/###/##. => ####/##../.###/##.#
###/###/##. => #..#/#.##/#.##/.#..
#.#/.../#.# => ####/#.#./#..#/.##.
###/.../#.# => .#../.#.#/.#../.#.#
###/#../#.# => ..#./..#./.###/#...
#.#/.#./#.# => #.#./..../.##./####
###/.#./#.# => #.../..##/.##./..#.
###/##./#.# => .#.#/##../#.#./..#.
#.#/#.#/#.# => #.##/#.##/#.##/..##
###/#.#/#.# => .###/#.#./.##./..##
#.#/###/#.# => ...#/#.#./..#./#..#
###/###/#.# => #.../#..#/#..#/.##.
###/#.#/### => .#.#/..##/##.#/#...
###/###/### => .###/#.#./#.../#..."""


def flip_it(array, flip=True):
    yield array
    yield rot90(array)
    yield rot90(rot90(array))
    yield rot90(rot90(rot90(array)))
    if flip:
        fv = flipud(array)
        yield fv
        fh = fliplr(array)
        yield fh
        yield from flip_it(fv, False)
        yield from flip_it(fh, False)


def split_list(inlist, size):
    retlist = []
    while len(inlist) > size:
        retlist.append(inlist[:size])
        inlist = inlist[size:]
    retlist.append(inlist)
    return retlist


def match(pattern):
    d = 2 if len(pattern) % 2 == 0 else 3
    splitted = split_list(pattern, d)
    pattern_array = [split_list(s, 1) for s in splitted]

    for pa in flip_it(pattern_array):
        # make subgroups of 2 or 3
        tmp = ''.join([''.join(p) for p in list(pa)])
        tmp = split_list(tmp, d * d)
        tmp = ['/'.join(split_list(t, d)) for t in tmp]

        if all(t in rules for t in tmp):
            output = ''.join([rules[t] for t in tmp])
            return output.replace('/', '')

    print('ERROR')


def magic(pattern, no):
    for i in range(no):
        pattern = match(pattern)
    return pattern


pattern = ".#...####"

rules = {}
for line in input.split('\n'):
    tmp = line.split(' => ')
    rules.update({tmp[0]: tmp[1]})
    some_pattern = [[c for c in sub] for sub in tmp[0].split('/')]
    for m in flip_it(some_pattern):
        flatten = '/'.join(''.join(sub) for sub in list(m))
        rules.update({flatten: tmp[1]})

print('First solution: {}'.format(magic(pattern, 5).count('#')))
print('Second solution: {}'.format(magic(pattern, 18).count('#')))
